<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Claude MCP Plugin</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        font-size: 12px;
        padding: 16px;
        color: #400B55;
        background-color: #FDF8FF;
      }
      .dark {
        color: #fff;
        background-color: #1e1e1e;
      }
      .mcp-plugin {
        display: flex;
        flex-direction: column;
        gap: 24px;
        height: 100%;
      }
      .mcp-plugin__header {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .mcp-plugin__header-title {
        font-size: 14px;
        margin: 0;
      }
      .mcp-plugin__header-description {
        font-size: 12px;
        margin: 0;
      }
      .mcp-plugin__content {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .mcp-plugin__connection-status {
        padding: 8px;
        border-radius: 4px;
        height: 32px;
        line-height: 1.35;
      }
      .mcp-plugin__connection-status.connected {
        background: #D8FFBB;
        color: #223005;
      }
      .mcp-plugin__connection-status.disconnected {
        background-color: #FFC8BD;
        color: #280B06;
      }
      .mcp-plugin__connection-status.info {
        background-color: #BBFFFD;
        color: #0B4240;
      }
      .mcp-plugin__channel-name {
        font-weight: bold;
        text-decoration: underline;
        cursor: pointer;
        position: relative;
      }
      .mcp-plugin__channel-name:hover {
        text-decoration: none;
      }
      .mcp-plugin__channel-name::after {
        content: "Click to copy";
        position: absolute;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #223005;
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: normal;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        pointer-events: none;
        z-index: 100;
      }
      .mcp-plugin__channel-name:hover::after {
        opacity: 1;
        visibility: visible;
      }
      .mcp-plugin__button {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 32px;
        width: 96px;
        border: 1px solid #732392; 
        background-color: #732392;
        color: #fff;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        margin-left: auto;
      }
      .mcp-plugin__button:hover {
        background-color: transparent;
        color: #732392;
      }
      .mcp-plugin__button--secondary {
        background-color: transparent;
        color: #732392;
      }
      .mcp-plugin__button--secondary:hover {
        background-color: #732392;
        color: #fff;
      }
      .dark .mcp-plugin__button:hover {
        background-color: transparent;
        color: #fff;
        border-color: #fff;
      }
      .dark .mcp-plugin__button--secondary {
        background-color: transparent;
        color: #fff;
        border-color: #fff;
      }
      .dark .mcp-plugin__button--secondary:hover {
        background-color: #732392;
        color: #fff;
        border-color: #732392;
      }
      .mcp-plugin__button:disabled {
        display: none;
      }
      .hidden {
        display: none !important;
      }
      /* Progress styles */
      .mcp-plugin__progress {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .mcp-plugin__progress-bar{
        width: 100%; 
        height: 4px; 
        background-color: #EDD0F8; 
        border-radius: 4px;
      }
      .mcp-plugin__progress-bar-fill{
        width: 0%; 
        height: 4px; 
        background-color: #732392; 
        border-radius: 4px; 
        transition: width 0.3s;
      }
      .mcp-plugin__progress-indicators,
      .mcp-plugin__progress-message {
        font-size: 12px;
      }
      #progress-status {
        opacity: 0;
      }
      .operation-error {
        color: #f87359ff;
      }
    </style>
  </head>
  <body class="">
    <div class="container mcp-plugin">
      <div class="header mcp-plugin__header">
        <h1 class="mcp-plugin__header-title">ðŸ¤– Claude Talk to Figma</h1>
        <p class="mcp-plugin__header-description">AI agents reading and modifing Figma designs</p>
      </div>
      <div class="content mcp-plugin__content">   
        <div id="connection-status" class="disconnected mcp-plugin__connection-status">
          Disconnected from serverâ€¦<br>Try to reconnect clicking the button
        </div>
        <button id="btn-connect" class="mcp-plugin__button mcp-plugin__button--primary">Connect</button>
        <button id="btn-disconnect" class="mcp-plugin__button mcp-plugin__button--secondary" disabled>
          Disconnect
        </button>
      </div>
      <!-- Add Progress Bar Section -->
      <div id="progress-container" class="hidden mcp-plugin__progress">
        <div class="mcp-plugin__progress-bar">
          <div id="progress-bar" class="mcp-plugin__progress-bar-fill"></div>
        </div>
        <div class="mcp-plugin__progress-indicators" style="display: flex; justify-content: space-between; font-size: 12px;">
          <div id="progress-status">Not started</div>
          <div id="progress-percentage">0%</div>
        </div>
        <div id="progress-message" class="mcp-plugin__progress-message">No operation in progress</div>
      </div>
    </div>

    <script>
      /**
       * ClaudeMCPPlugin Class
       * Managed WebSocket connection, Figma communication, and UI state.
       */
      class ClaudeMCPPlugin {
        constructor() {
          this.state = {
            connected: false,
            socket: null,
            serverPort: 3055,
            pendingRequests: new Map(),
            channel: null,
          };

          // Cache DOM elements
          this.ui = {
            connectBtn: document.getElementById("btn-connect"),
            disconnectBtn: document.getElementById("btn-disconnect"),
            connectionStatus: document.getElementById("connection-status"),
            progressContainer: document.getElementById("progress-container"),
            progressBar: document.getElementById("progress-bar"),
            progressMessage: document.getElementById("progress-message"),
            progressStatus: document.getElementById("progress-status"),
            progressPercentage: document.getElementById("progress-percentage"),
          };

          this.init();
        }

        init() {
          // Event Listeners
          this.ui.connectBtn.addEventListener("click", () => this.connect());
          this.ui.disconnectBtn.addEventListener("click", () => this.disconnect());

          // Clipboard feature using event delegation
          this.ui.connectionStatus.addEventListener("click", (e) => {
            if (e.target.classList.contains("mcp-plugin__channel-name")) {
              this.copyToClipboard(e.target.textContent);
            }
          });

          // Figma messages
          window.onmessage = (event) => this.handleFigmaMessage(event.data.pluginMessage);
        }

        /**
         * Update the connection status UI
         */
        updateStatus(isConnected, message) {
          this.state.connected = isConnected;
          this.ui.connectionStatus.innerHTML =
            message ||
            (isConnected
              ? "Connected to Claude MCP server"
              : "Not connected to Claude MCP server");
          
          this.ui.connectionStatus.className = `mcp-plugin__connection-status ${
            isConnected ? "connected" : (message && message.includes("Connecting") ? "info" : "disconnected")
          }`;

          this.ui.connectBtn.disabled = isConnected;
          this.ui.disconnectBtn.disabled = !isConnected;
        }

        /**
         * Connect to WebSocket server
         */
        async connect(port = 3055) {
          try {
            if (this.state.connected && this.state.socket) {
              this.updateStatus(true, "Already connected to server");
              return;
            }

            this.updateStatus(false, "Connecting...");
            this.ui.connectionStatus.className = "mcp-plugin__connection-status info";
            
            this.state.serverPort = port;
            this.state.socket = new WebSocket(`ws://localhost:${port}`);

            this.state.socket.onopen = () => {
              const channelName = this.generateChannelName();
              console.log("Joining channel:", channelName);
              this.state.channel = channelName;

              this.state.socket.send(
                JSON.stringify({
                  type: "join",
                  channel: channelName.trim(),
                })
              );
            };

            this.state.socket.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                console.log("Received message:", data);

                if (data.type === "system") {
                  if (data.message && data.message.result) {
                    this.state.connected = true;
                    const channelName = data.channel;
                    this.updateStatus(
                      true,
                      `Connected on port ${port}!<br>Copy the channel ID: <span class="mcp-plugin__channel-name" title="Click to copy">${channelName}</span>`
                    );

                    parent.postMessage(
                      {
                        pluginMessage: {
                          type: "notify",
                          message: `Connected on port ${port}. In channel: ${channelName}`,
                        },
                      },
                      "*"
                    );
                  }
                } else if (data.type === "error") {
                  console.error("Error:", data.message);
                  this.updateStatus(false, `Error: ${data.message}`);
                  this.state.socket.close();
                }

                this.handleSocketMessage(data);
              } catch (error) {
                console.error("Error parsing message:", error);
              }
            };

            this.state.socket.onclose = () => {
              this.state.connected = false;
              this.state.socket = null;
              this.updateStatus(false, "Disconnected from serverâ€¦<br>Try to reconnect clicking the button");
            };

            this.state.socket.onerror = (error) => {
              console.error("WebSocket error:", error);
              this.updateStatus(false, "Connection error");
              this.state.connected = false;
              this.state.socket = null;
            };
          } catch (error) {
            console.error("Connection error:", error);
            this.updateStatus(
              false,
              `Connection error: ${error.message || "Unknown error"}`
            );
          }
        }

        /**
         * Disconnect from WebSocket server
         */
        disconnect() {
          if (this.state.socket) {
            this.updateStatus(false, "Disconnecting...");
            this.ui.connectionStatus.className = "mcp-plugin__connection-status info";
            this.state.socket.close();
            this.state.socket = null;
            this.state.connected = false;
          }
        }

        /**
         * Handle messages from the WebSocket server
         */
        async handleSocketMessage(payload) {
          const data = payload.message;
          if (!data) return;
          console.log("handleSocketMessage", data);

          // If it's a response to a previous request
          if (data.id && this.state.pendingRequests.has(data.id)) {
            const { resolve, reject } = this.state.pendingRequests.get(data.id);
            this.state.pendingRequests.delete(data.id);

            if (data.error) reject(new Error(data.error));
            else resolve(data.result);
            return;
          }

          // If it's a new command
          if (data.command) {
            try {
              parent.postMessage(
                {
                  pluginMessage: {
                    type: "execute-command",
                    id: data.id,
                    command: data.command,
                    params: data.params,
                  },
                },
                "*"
              );
            } catch (error) {
              this.sendErrorResponse(data.id, error.message || "Error executing command");
            }
          }
        }

        /**
         * Handle messages from Figma
         */
        handleFigmaMessage(message) {
          if (!message) return;
          console.log("Received message from plugin:", message);

          switch (message.type) {
            case "connection-status":
              this.updateStatus(message.connected, message.message);
              break;
            case "auto-connect":
              this.connect();
              break;
            case "auto-disconnect":
              this.disconnect();
              break;
            case "command-result":
              this.sendSuccessResponse(message.id, message.result);
              break;
            case "command-error":
              this.sendErrorResponse(message.id, message.error);
              break;
            case "command_progress":
              this.updateProgress(message);
              this.sendProgressUpdate(message);
              break;
          }
        }

        /**
         * Send success response to server
         */
        sendSuccessResponse(id, result) {
          if (!this.state.connected || !this.state.socket) return;
          this.state.socket.send(
            JSON.stringify({
              id,
              type: "message",
              channel: this.state.channel,
              message: { id, result },
            })
          );
        }

        /**
         * Send error response to server
         */
        sendErrorResponse(id, errorMessage) {
          if (!this.state.connected || !this.state.socket) return;
          this.state.socket.send(JSON.stringify({ id, error: errorMessage }));
        }

        /**
         * Update Progress UI
         */
        updateProgress(data) {
          this.ui.progressContainer.classList.remove("hidden");
          const progress = data.progress || 0;
          this.ui.progressBar.style.width = `${progress}%`;
          this.ui.progressPercentage.textContent = `${progress}%`;
          this.ui.progressMessage.textContent = data.message || "Operation in progress";

          if (data.status === 'started' || data.status === 'in_progress') {
            this.ui.progressStatus.textContent = data.status === 'started' ? "Started" : "In Progress";
            this.ui.progressStatus.className = "";
          } else if (data.status === 'completed') {
            this.ui.progressStatus.textContent = "Completed";
            this.ui.progressStatus.className = "operation-complete";
            setTimeout(() => this.ui.progressContainer.classList.add("hidden"), 5000);
          } else if (data.status === 'error') {
            this.ui.progressStatus.textContent = "Error";
            this.ui.progressStatus.className = "operation-error";
          }
        }

        /**
         * Relay progress update to server
         */
        sendProgressUpdate(data) {
          if (!this.state.connected || !this.state.socket) return;
          this.state.socket.send(
            JSON.stringify({
              id: data.commandId,
              type: "progress_update",
              channel: this.state.channel,
              message: {
                id: data.commandId,
                type: "progress_update",
                data: data
              }
            })
          );
        }

        /**
         * Copy text to clipboard and notify
         */
        async copyToClipboard(text) {
          try {
            // Try modern API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              this.notifyCopied(text);
            } else {
              throw new Error("Clipboard API not available");
            }
          } catch (err) {
            // Fallback to execCommand('copy')
            try {
              const textArea = document.createElement("textarea");
              textArea.value = text;
              textArea.style.position = "fixed";
              textArea.style.left = "-9999px";
              textArea.style.top = "0";
              document.body.appendChild(textArea);
              textArea.focus();
              textArea.select();
              const successful = document.execCommand('copy');
              document.body.removeChild(textArea);
              if (successful) {
                this.notifyCopied(text);
              } else {
                throw new Error("execCommand('copy') failed");
              }
            } catch (fallbackErr) {
              console.error("All copy methods failed:", fallbackErr);
            }
          }
        }

        /**
         * Notify Figma about clipboard success
         */
        notifyCopied(text) {
          parent.postMessage({
            pluginMessage: {
              type: "notify",
              message: `Channel ID copied: ${text}`,
            },
          }, "*");
        }

        /**
         * Utils
         */
        generateId() {
          return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        generateChannelName() {
          const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
          let res = "";
          for (let i = 0; i < 8; i++) res += chars.charAt(Math.floor(Math.random() * chars.length));
          return res;
        }
      }

      // Initialize the plugin
      const plugin = new ClaudeMCPPlugin();
    </script>
  </body>
</html>